## Equation  

> Below is the challenge code in python.  

```python
from Crypto.Util.number import bytes_to_long

FLAG = <REDACTED>

n = len(FLAG)
m1 = bytes_to_long(FLAG[:n//2])
m2 = bytes_to_long(FLAG[n//2:])

print(13 * m2 ** 2 + m1 * m2 + 5 * m1 ** 7)
print(7 * m2 ** 3 + m1 ** 5)

# 13 * m2 ** 2 + m1 * m2 + 5 * m1 ** 7 == 6561821624691895712873377320063570390939946639950635657527777521426768466359662578427758969698096016398495828220393137128357364447572051249538433588995498109880402036738005670285022506692856341252251274655224436746803335217986355992318039808507702082316654369455481303417210113572142828110728548334885189082445291316883426955606971188107523623884530298462454231862166009036435034774889739219596825015869438262395817426235839741851623674273735589636463917543863676226839118150365571855933
# 7 * m2 ** 3 + m1 ** 5 == 168725889275386139859700168943249101327257707329805276301218500736697949839905039567802183739628415354469703740912207864678244970740311284556651190183619972501596417428866492657881943832362353527907371181900970981198570814739390259973631366272137756472209930619950549930165174231791691947733834860756308354192163106517240627845889335379340460495043
#
```

> We are given 2 polynomial equations and the goal is to find its roots, m1 and m2, which represents a portion of the flag (first half and second half respectively).  

> We will use [SageMath](https://sagecell.sagemath.org/) for this. The tutorial on how to work with Multivariate Polynomials can be found [here](https://nusgreyhats.org/posts/guides/sage_note/#multivariate-polynomial)

> Below is the code to solve the challenge:

```python
R.<m1,m2> = QQ[]
f = 13 * m2 ** 2 + m1 * m2 + 5 * m1 ** 7 - 6561821624691895712873377320063570390939946639950635657527777521426768466359662578427758969698096016398495828220393137128357364447572051249538433588995498109880402036738005670285022506692856341252251274655224436746803335217986355992318039808507702082316654369455481303417210113572142828110728548334885189082445291316883426955606971188107523623884530298462454231862166009036435034774889739219596825015869438262395817426235839741851623674273735589636463917543863676226839118150365571855933
g = 7 * m2 ** 3 + m1 ** 5 - 168725889275386139859700168943249101327257707329805276301218500736697949839905039567802183739628415354469703740912207864678244970740311284556651190183619972501596417428866492657881943832362353527907371181900970981198570814739390259973631366272137756472209930619950549930165174231791691947733834860756308354192163106517240627845889335379340460495043

flag = ""

# get m1
k = f.resultant(g, m2)
k = k(m2 = 0)
k = k.univariate_polynomial()
m1_dec = k.roots()[0][0]
print(m1_dec)
flag += bytes.fromhex(str(hex(m1_dec))[2:]).decode("utf-8")

# get m2
k = f.resultant(g, m1)
k = k(m1 = 0)
k = k.univariate_polynomial()
m2_dec = k.roots()[0][0]
print(m2_dec)
flag += bytes.fromhex(str(hex(m2_dec))[2:]).decode("utf-8")

print(flag)
```

![image](https://github.com/Rookie441/CTF/blob/main/Categories/Cryptography/Easy/equation/SageMath.PNG)  

> An alternative approach is to take the most significant exponent and ignore the rest of the terms with lower degree. The writeup can be found [here](https://github.com/jontay999/CTF-writeups/blob/master/GreyCTF%202022/Crypto/equation1.md), the code can be found at [solver.py](https://github.com/Rookie441/CTF/blob/main/Categories/Cryptography/Easy/equation/solver.py)

`grey{solving_equation_aint_that_hard_rite_gum0pX6XzA5PJuro}`
